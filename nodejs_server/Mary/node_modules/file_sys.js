// Copyright Neal Raulerson 2019. All Rights Reserved.

"use strict";

/* requires */
const fs = require("fs");

const folder = {};

folder.delete = function (folder_path) {
    if (!fs.existsSync(folder_path)) {
        return;
    }

    let del_paths = fs.readdirSync(folder_path, "utf8")
        .map(path => `${folder_path}/${path}`);
    let del_folders = [folder_path];

    for (let i = 0; i < del_paths.length; i += 1) {
        const del_path = del_paths[i];
        if (fs.statSync(del_path).isDirectory()) {
            const folder_del_paths = fs.readdirSync(del_path, "utf8")
                .map(path => `${del_path}/${path}`);
            del_paths = del_paths.concat(folder_del_paths);
            del_folders.push(del_path);
        } else {
            fs.unlinkSync(del_path);
        }
    }

    for (let del_folder of del_folders.reverse()) {
        fs.rmdirSync(del_folder);
    }
};

folder.create = function (folder_path) {
    const folder_paths = folder_path.split("/");
    let path_parts = "";
    for (let folder_path of folder_paths) {
        path_parts += folder_path + "/";
        if (!fs.existsSync(path_parts)) {
            fs.mkdirSync(path_parts);
        }
    }
};

folder.copy = function (from_folder_path, to_folder_path, options = {}) {
    /* options */
    if (!options.exclusions) {
        options.exclusions = [];
    }
    if (!options.delete_source) {
        options.delete_source = false;
    }
    if (!options.delete_destination) {
        options.delete_destination = false;
    }

    /* exclusions */
    const path_cleanup_regex = /^\.?\/*/;
    const path_error_regex = /^\.\./;
    const exclusions = [].concat(options.exclusions)
        .map(path => path.replace(path_cleanup_regex, "/"));
    exclusions.forEach(path => {
        if (path_error_regex.test(path)) {
            throw new Error("there is a problem with the exclusions.");
        }
    });

    if (options.delete_destination) {
        folder.delete(to_folder_path);
    }

    folder.create(to_folder_path);

    const file_regex = /\/[^/]+$/;
    let copy_paths = [from_folder_path];

    for (let i = 0; i < copy_paths.length; i += 1) {
        const copy_path = copy_paths[i];

        if (exclusions.includes(copy_path.replace(from_folder_path, ""))) {
            continue;
        }

        if (fs.statSync(copy_path).isDirectory()) {
            const folder_copy_paths = fs.readdirSync(copy_path, "utf8")
                .map(path => `${copy_path}/${path}`);
            copy_paths = copy_paths.concat(folder_copy_paths);
        } else {
            const folder_path = copy_path.replace(file_regex, "")
                .replace(from_folder_path, to_folder_path);
            if (!fs.existsSync(folder_path)) {
                fs.mkdirSync(folder_path);
            }
            const file_path = copy_path.replace(from_folder_path, to_folder_path);
            fs.copyFileSync(copy_path, file_path);
        }
    }

    if (options.delete_source) {
        folder.delete(from_folder_path);
    }
};

const file = {};

file.copy = async function (from_file_path, to_file_path) {
    return new Promise(function (res) {
        fs.copyFile(from_file_path, to_file_path, function (err) {
            err ? res(false) : res(true);
        });
    });
};

/* exports */
module.exports = {
    folder,
    file
};
